# Design-Verification
The Design Verification Repo Captures my work from basic understanding and projects I have worked on. 

## UVM
The UVM Class Library provides the building blocks needed to quickly develop well-constructed and reusable verification components and test environments in SystemVerilog.
We divide the UVM classes and utilities into categories pertaining to their role or function.
- **Base :** This basic building block for all environments are components, which do the actual work, transactions, which convey information between components and ports, which provide the interfaces used to convey the information.
- **Components :** The components for the foundation of UVM. They encapsulate behaviour of drivers, monitors, scoreboards, environments, agents, test and other objects in Testbench.
- **Reporting :** The reportin classes provide the facility for issuing messages with consistent formatting and configurable side effects like logging a file or exiting simulation.
- **Factory :** The factory method is used to register the uvm_object or uvm_component classes. Users can configure the factory to produce an object of a given type on a global or instance basis.
- **Phases :** It describes the phasing capability providing by UVM.
- **TLM :** The UVM TLM library defines several abstract, transaction-level interfaces and the ports and exports that facilitate their use. Each TLM interface consists of one or more methods used to transport data, typically whole transactions (objects) at a time.
- **Sequencers :** The sequencer controls the flow of uvm_sequence_item-based transactions generated by one or more uvm_sequence #(REQ,RSP)-based sequences.
- **Sequences :** The sequences can be reused, extended, randomized, and combined sequentially and hierarchically in interesting ways to produce realistic stimulus to your DUT.
- **Macros :** A complete list of macros for Reporting, Components, Objects, Sequences, Callbacks, TLM and Registers.
- **Register Layer :** The Register abstraction classes, when properly extended, abstract the read/write operations to registers and memories.
- **Command Line Processor :** A general interface to the command line arguments that were provided for the given simulation.


For reference of understanidng the Syntax or Usage I refer following links :
- Link1 : https://www.accellera.org/images/downloads/standards/uvm/UVM_Class_Reference_Manual_1.2.pdf
- Link2 : https://www.accellera.org/images//downloads/standards/uvm/uvm_users_guide_1.2.pdf
- Link3 : Once we download the UVM library. We get index.html page from UVM-18002-2017-11tar/uvm-1.2/uvm-1.2/docs/html/index.html.

## UVM Dynamic and Static
**Base Class**
- **uvm_object**: Dynamic Class
  - uvm_transaction
  - uvm_sequence_item
  - uvm_sequence
- **uvm_component** : Static Class
  - uvm_driver
  - uvm_monitor
  - uvm_agent
  - uvm_scoreboard
  - uvm_env
  - uvm_test

## UVM_TREE 

                                        uvm_top (root)
                                           |
                                           |
                                           |
                                           |
                                           |
                                          Test (root)
                                           |
                                           |
                                           |
                                           |
                                    Environment (subtree)
                                            |
                            |                                       |
                            |                                       |
                            |                                       |
                    Scoreboard(subtree)                         Agent(subtree)
                                                                    |
                                                    |               |               |
                                                    |               |               |
                                                Monitor         Driver          Sequencer


## UVM Testbench Architecture

The UVM Testbench Architecture composes of : 
- Transaction :
  - The Transaction class in general composes of the signals of the DUT.
  - The signals can be Constrainted and Randomized on certain conditions.
  - These transaction class is used by Sequencer, Driver and Monitor.
- Sequencer :
  - The Sequencer in general is used to generate the Sequences for the DUT. The sequences are sent to driver using TLM seq_item_export port.
  - In general there can different sequences/testcases for given DUT.
- Driver :
  - The Driver in general is used to drive the transactions/sequences to DUT through Interfaces.
- Monitor :
  - The Monitor is used to collect the trasnactions/responses from the DUT through Interfaces. The collected responses are sent to Scoreboard through TLM port.
- Agent :
  - The Agent class that encapsulates the Driver, Sequencer and Monitor. The reason for doing this is we can have Multiple agents and reconfigurability or reuse nature for different DUTs.
  - In this class we generally connect the TLM port of Driver and Sequencer.
- Scoreboard :
  - The Scoreboard is used to cross veirfy or compare the transactions between the Golden data and Collected responses from the TLM port.
- Environment :
  - The Environment class encapsulates the Agent and Scoreboard.
  - The reason for doing this is we can reconfigure or reuse nature for different DUTs.
  - In this class we generally connect the TLM port of Monitor and Scoreboard.
- Test :
  - The Test class encapsulates the Sequencer and Environment.
  - In the run_phase of the test class we drive or start the sequences/testcases for the DUT.
- Interface :
  - The Interface is used to connect between Dynamic class and Module (Static in nature).
  - The Interface provides modports and clocking blocks with it.
  - In general the Interface blocks can be reused for multiple Testbench top.
- DUT :
  - In general the RTL block or Design code is used as DUT.
  - A Block implementing the Design Specification if the RTL/Design code is not ready. Used to verify the intended testcase.
- TB_Top :
  - The Encapsulation of Test, Interface and DUT.

![image](https://github.com/user-attachments/assets/ffeef25f-5e75-4f78-9146-1e4bcb624f06)

## UVM Phases
        UVM Phases    
            a. Consume time : task                                        
                - run_phase.

            b. Do not consume time : function
                - function and super to override the specific method.
                - configuring the envirnoment.
                - creating object of class.
                - applying stimulus to DUT on valid clock edge.
                - Construction phase.
                - Cleanup phase.

        Phases : Total = 20
            a.  Construction Phase  (4 phases)                                                                             
                    (Override the specific function method according to our needs)
                    - build_phase               : Create an object of a class.
                    - connect_phase             : Connection of component in TLM.
                    - end_of_elaboartion_phase  : Adjust an hierarchy of component.
                    - start_of_simulation       : Configure an environment before applying the stimulus.

            b.  run_phase (12 phases)           : Task based and consume time.
                    - reset_phase               : System reset - Bring the system/block or anything to known state. Then start working
                        - pre_reset_phase       :
                        - post_reset_phase      :   
                    - configure_phase           : Memory/Variables/Arrays : initialize them to specific value before start of generating stimulus.
                        - pre_configure_phase   :
                        - post_configure_phase  :
                    - main_phase                : Generating stimulus + collecting responses.
                        - pre_main_phase        :
                        - post_main_phase       :
                    - shutdown_phase            : All the stimuli generated are applied correctly to DUT. 
                        - pre_shutdown_phase    :
                        - post_shutdown_phase   :
            
            c.  cleanup_phase : collect and report data. coverage goals are achieved. (4 phases)
                    - extract phase             :
                    - report phase              :
                    - check phase               :
                    - final phase               :

The flow/sequence of execution of phase :

1. Build Phase executed.
2. Connect Phase executed.
3. End of Elaboration Phase executed.
4. Start of Simulation Phase executed.
5. Run Phase.
6. Extract Phase.
7. Check Phase.
8. Report Phase.
9. Final Phase.

## UVM Adder 
In order to explain above concepts a simple project Links : 
- Code Link      : https://github.com/ssbagi/Design-Verification/blob/main/UVM_ADDER/uvm_adder.svh
- Directory Link : https://github.com/ssbagi/Design-Verification/tree/main/UVM_ADDER

## UVM APB Infrastructure
In order to explain above concepts a complex project Links : 
- Code Link      :
- Directory Link :






